Project:  pccbr-compiler Project Symbol Table
Authors:  Carter J. Bastian, Quinn Stearns

We have udpated the pccbr compiler to include support for generating an intermediate
representation of our source. This update comes with a major restructuring of our
source code (outlined below). Our quadgen code creates a linked list of three-address
operations that will be easily converted in assembly.

In order to build the quad generator:

cd src/quadgen
make

In order to execute our tests, run:

src/quadgen/quadTests.sh

We confirmed the results of our test cases manually.

Relevant source code appears primarily in quadgen/quadgen.c. Our quad data structures
are defined in quadgen.h.
FILES:

|__src
   |__lexer
   |  |__cscan.c
   |  |__cscan.l
   |
   |__parser
   |  |__parser.y
   |  |__ast_main.c
   |
   |__symtab
   |  |__buildtab.c
   |
   |__symcheck
   |  |__treecheck.c
   |
   |__share
   |  |__types.h
   |
   |__util
   |  |__ast.c
   |  |__symtab.c
   |
   |__quadgen
      |__quadgen.c
      |__quad_main.c


  - symtab.c
    Implementations of symbol table functions declared in ast.c

  - symtab.h
    Definitions of symbol table datatypes and related function prototypes
  - ast.c
    Implementations of the AST-related utility functions declared in ast.h

  - ast.h
    Definitions of AST datatypes and declarations of AST utility functions

  - cscan.l
    The lexer for the parser. Slightly modified from it's original state

  - parser.y
    The parser defines the grammar, constructs ASTs, and handles/reports errors

  - symbol_main.c
    A simple driver to build and traverse the parse tree to make a symbol table
    Also does a bottom up traversal of the parse tree to verify its consistency

  - ast_main.c
    A simple driver to only build a parse tree using the grammar in parser.y

  - quadgen.c
    This file contains our implementation of a IR-generator, which genrates three
    address quads

DEPENDENCIES:
- Our build requires Bison 3.0.0 or later. Notice that Mac's generally have an
  older version of this software, while the Sudikof Lab machines have version
  3.0.2


NOTES ON SYMBOL TABLE DESIGN:
- Our naming protocol is as follows:
  i. The first level is 0 (and this level "0-" is ommitted from all other names)
  ii. Any subsequent depth is denoted with a '-'
  iii. Siblings in the parse tree are those named with the same prefix

  EXAMPLE: 1-0-1-2-3 and 1-0-1-2-5 are siblings, while 1-0-1-1-4 is not.

- Because of the minimalist structure of our parse tree, some fancy looping is
  necessary in the build_symboltable function of symbols_main.c
  
  Specifically, we really only need to concern ourselves with declarations in 
  the cases of ROOT_N (where functions and globals can be declared),
  COMPOUND_STMT_N (where new local variables can be declared and a new scope
  is entered), and FUNC_N (where we can get parameters).

  In other cases, we simply recurse on the children nodes of the AST and return
  without modifying scope or adding to the symbol table.

  However, for each of these three cases, there are unique edge cases which must
  be tested for such as
    - Compound statements consisting solely of declarations
    - Compound statements with no declarations
    - Errors nodes in the declarations
    - A non-declaration error node immediately following valid declarations
    - Functions with no or void parameters
    - Functions with array parameters
    - A root with multiple functions 
    - ETC.


IMPORTANT NOTE ON AST REPRESENTATION OF ARRAY VARIABLES:
  On the last checkpoint, we were docked points becuase our array and non-array
  identifiers are all collected under the ID_N ast_node type. However, this is
  an intentional design decision on our part.
  
  For any non-array identifier, the value_int field of it's ast_node is set to
  zero.

  For a declared array, the number of items it's declared as having is stored in
  the value_int field of its ast_node.

  For an ID representing access into an array, it's ast_node's value_int
  field is set to -1 and it's leftmost (and only) child is the expression
  used as the index.

  This design allows us to differentiate between array declaration and access 
  with the AST alone and is being used with extensibility to other data types
  (extra credit) down the road. If there is a fundamental issue with this,
  please let us know asap. 

  To see this in action, see arrayTest.ast and arrayTest.sym in the outfiles/
  directory.


UPDATES TO LEXER AND PARSER:
- Fixed a bug in which the parser failed to copy the correct name of the 
  function into the ast_node->value_string field.
- Fixed a bug in which multiple-declarations (eg int a,b, c = 5;) were parsed
  as only a single declaration.
- Added semantic differentiation between ID of normal parameters and IDs of 
  array parameters.
- Added semantic differentiation between variables used in an expression
  (ID_N) and variables used in a declaration (DEC_ID_N).
- Changed the way we handle arrays (the note on symbol table design above)

ERROR REPORTING AND RECOVERY:
  Note that we concern ourselves in the symbol table only with those error 
  nodes which are due to Invalid Variable Declarations. All others are ignored
  while traversing the AST.

  Further, we mark that there was a variable in that scope which was declared,
  but which was done so invalidly. In this way, we will still be able to check
  for valid variable use w/ respect to scope in future projects even in the
  event of code with parse errors.

  Edge cases related to error reporting and recovery are tested in the file
  testfiles/declaredErrors.c

NOTES ON SYMBOL CHECKER:
To test our submission for the bottom-up symbol and type checker, please execute
bottomUpTests.sh to see all of our test cases. The output from the checker will
appear above the symbol table and ast print outs.

We modified our parser to include line numbers in its saving of the tree and also
recorded a reference to the ast node that defines new function scopes to make it easier
to find that in our symbol table checker. We also added a reference to the scope in the
ast to make it easier to traverse the symbol scopes.

USAGE:
To build and print the symbol table for any given file:
  make clean; make; ./symtab < FILE_NAME

To build and print ONLY the AST for any given file:
  make clean; make parse; ./parse < FILE_NAME

To run our test suite (see below):
  ./autoTest.sh


AUTOMATED TESTING:
  By running the autoTest.sh script as described above, you will run a series of
  all the test inputs we have written (all of which are in the testfiles/ 
  directory). All of the output will be placed in the outfiles/ directory.

  Notice that both the AST and the Symbol Table are output by this shell script
  for easy comparison. We recommend comparing both of these output files
  next to the input .c file.

  Output AST's have the extension ".ast" and output symbol tables have the
  extension ".sym".

  All .ast and .sym files were checked by hand to ensure they were accurate 
  representations of their respective c-files.


SUMMARY OF TESTS (FILES):
Those Special to the 
  - arrayTest
    Testing and demonstration of how the Symbol Table generator handles arrays
    as declared variables and parameters at differing scopes.

  - declaredErrors
    Edge cases with scope/declaration-relevant error report and recovery.

  - scopeTest
    Testing with deep scopes, many siblings, and edge cases, etc.
    (This is where we discovered most of our bugs).

  - textbook
    The example from C&T Engineering a Compiler (2nd Edition) Figure 5.10-5.12

Those continued from parser testing (Described in the parser README):
  - contolFlow
  - danglingElse
  - errTest
  - expressions
  - forLoop
  - functions
  - generalTest
  - loops

