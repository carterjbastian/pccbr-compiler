Project:  pccbr-compiler project Lexer
Authors:  Carter J. Bastian, Quinn Stearns

FILES:
  - ast.c
    Implementations of the AST-related utility functions declared in ast.h

  - ast.h
    Definitions of AST datatypes and declarations of AST utility functions

  - cscan.l
    The lexer for the parser. Slightly modified from it's original state.

  - parser.y
    The parser defines the grammar, constructs ASTs, and handles/reports errors.

  - ast_main.c
    A simple driver to build the parse tree. Also contains the testing suite.

NOTES ON AST DESIGN:
  For the most part, our design was fairly standard. Most binary operation nodes
  contain children (the operands). Analogously, unary operations contain one 
  child node. Some specific node types have structures worth commenting on.  

  Any "list" nodes are really only the first item in the list, with each
  successive node in the list pointed to by its direct left sibling in the tree.
  Whenever a parent node has a list as a child, an effort was made to ensure
  that the list-type node would be the right-most child.

  Function nodes (FUNC_N) consist of a compound statement as the left-most
  child, followed by a list of parameters. Notice that function nodes get a
  value_int of 1 if they return an int, and a value_int of 0 if they return
  void.

  Compound statement nodes (COMPOUND_STMT_N) consist of two lists: first, a list
  of declarations, followed imediately by a list of statements.

  If statement nodes (IF_N), consist of two children: on the left, an expression
  which is the conditional for the if statement, and on the right, a statement
  (potentially compound) to execute if the conditional is true.

  If-Else statements (IF_ELSE_N) are identical, except for the addition of a
  third child â€“ a statement node to be executed in the conditional is false.

  For both While statements and Do-While statements (WHILE_N and DOWHILE_N
  respectively), the conditional expression is the leftmost-child, followed
  by the statement to execute while the condition is true.

  For-Loop nodes (FOR_N) have the three header expressions (in order from left-
  to-right) as their three leftmost children, follwed immediately by a statement
  node (the body of the loop).

  Empty Nodes (NULL_N) are used throughout wherever a node is optional in code, 
  but necessary to preserve the expected structure of the AST (for example, with
  empty for-loop header statements).


ERROR REPORTING AND RECOVERY:
  All error reporting and recovery happens at the statement-level.
  Fairly specific errors can be reported this way without having to 
  jeapordize the semantic meaning of the structure of the AST.

  A statement that's a recognized error will simply be ignored. The rest of the
  tree will be constructed as if the error statement had never occurred.
  However, an error node (ERROR_N) is created and placed in the tree where
  the node should have been placed.

  Notice that if there is a problem in the construction of a loop or control
  construct, the entire node (including it's body and the statements therein)
  will be ignored. However, if you have an error in the body of a malformed
  loop or control statement, the error will still be reported even though 
  the corresponding error node is not included in the tree.

USAGE:
  To parse a file "example.c", use the following chain of commands from the 
  source directory:
    
    make; ./parser < example.c

AUTOMATED TESTING:
  Conditional compilation was used to automate the testing process.

  Note that all test files must be in the testfiles/ directory, and the output
  AST for each respective file will be placed in the output/ directory.

  Also note that, to add additional tests, one must modify the header file
  testfiles/autoTest.h (while following the notes and instructions in the
  inline documentation).

  To run the test suite, use the following commands from the source directory:

    make test; ./test

  Notice also that the dangling else construction is tested with the file
  testfiles/danglingElse.c but that this is not tested by default in the auto
  testing since it fails to build an AST at all. To test this, run the command:
  
    make; ./parser < testfiles/danglingElse.c


TESTS (FILES):
  Below is a list of test files used which comprises those in our test suite:

  forLoop.c     - Displays the capability to parse a simple for loop
  loops.c       - Displays nested-loop functionality and all types of supported 
                  loops
  generalTest.c - Displays most of the functionalities of the C programming
                  language with general purpose testing
  expressions.c - Displays the parser's ability to work with complex expressions
  controlFlow.c - Displays the parser's if-else and if capabilities
  functions.c   - Displays the parser's ability to handle functions of different
                  types and numbers of parameters (as well as respective calls)
  errTest.c     - Displays all error report and recovery functionality

  danglingElse.c is a non-parsing file that shows that dangling else 
    constructions fail.
  
